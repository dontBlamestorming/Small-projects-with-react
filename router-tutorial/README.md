## 리액트 라우터로 SPA 개발하기

### 기존의 웹브라우저

1. 사용자가 다른 페이지로 이동할 떄마다 새로운 html을 받아오고, 페이지를 loading할 때마다 서버에서 리소스를 전달받아 해석한 뒤 화면에 출력
2. 즉, 사용자에게 보이는 화면을 서버측에서 준비하는 것이다. 먼저 html 파일을 만들어서 제공하거나 데이터에 따라 유동적인 html을 생성하는 템플릿 엔진을 사용하기도 함.
3. 하지만 요즘은 Web에서 제공되는 정보의 양이 증가하여 클라이언트의 요청에 따라 서버 측에서 모든 응답을 준비한다면 성능상의 문제가 발생할 가능성이 존재
4. 예를들면 트래픽이 너무 많이 나온다던지, 사용자가 몰리는 순간에 서버에 높은 부하가 걸림. html을 서버에 계속 요청하면 사용자의 상태관리에도 부적절

### SPA란?

- SPA는 Single Page Application이다. 이는 뷰 렌더링을 사용자의 브라우저가 담당하도록 하고 우선 애플리케이션을 브라우저에 불러와 실행시킨다.
- 사용자와 브라우저간의 interaction이 발생하면 필요한 부분만 자바스크립트로 업데이트해준다.
- 만약 데이터가 필요하다면 서버 api를 호출하여 필요한 데이터만 새로 불러와 애플리케이션에서 사용한다.
- SPA의 경우 서버에서 사용자에게 제공하는 페이지는 한 종류지만, 해당 페이지에서 loading된 자바스크립트와 주소상태에 따라 다양한 화면을 보여줄 수 있음.
- 이 떄, 다른 주소에 다른 화면을 보여주는 것을 routing이라고 한다.
- react-router는 clinet side에서 이루어지는 routing을 아주 간단하게 구현할 수 있게 해준다.

### SPA의 단점

1. 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다. 왜냐하면 페이지 loading을 할 때, 사용자가 방문하지도 않을 부분까지 loading하기 때문
2. 하지만 이는 코드 스플리팅(code splitting)을 사용하면 route별로 파일을 나누어서 트래픽와 속도를 개선시킬 수 있다.
3. 자바스크립트를 사용하지 않는 일반 크롤러에서는 페이지의 정보를 제대로 수집해 가지 못한다는 잠재적인 단점이 있다. 이 또한 서버 사이드 렌더링을 통해 해결할 수 있다.

### react-router-dom

1. <BrowserRouter />

- 이 컴포넌트는 HTML5의 History API를 사용하여 페이지를 새로고침하지 않고 주소를 변경, 또는 현재 주소에 관련된 정보를 props로 쉽게 조회하거나 사용할 수 있도록 해준다.

2. <Link />

- react-router를 사용할 땐 <a>를 직접 사용하면 안된다. <a>는 페이지를 전환하는 과정에서 페이지를 새로 불러오기 때문에 애플리케이션이 들고 있던 상태들을 모두 날려버린다. 컴포넌트도 모두 사라지고 처음부터 렌더링하게 한다.
- Link 컴포넌트를 사용하여 페이지를 전환하면, 페이지를 새로 불러오지 않고 애플리케이션은 유지한 상태에서 HTML5 History API를 사용하여 페이지의 주소만 변경해 준다. 이 컴포넌트 자체는 <a>로 이루어져 있지만 페이지전환을 방지하는 기능이 내장되어 있다.

### URL 파라미터와 URL 쿼리

페이지 주소를 정의할 때 가끔은 유동적인 값을 전달해야 할 때도 있다. 이는 파라미터와 쿼리로 나눌 수 있다. 이 두 기능을 쓰는데에 있어서 URL 파라미터는 match 객체, URL 쿼리는 location 객체를 잘 살펴보자.

1.  URL 파라미터 예시 : /profiles/dave

    > URL 파라미터를 사용할 땐 route로 사용되는 컴포넌트에서 받아오는 match객체의 params값을 참조한다.
    > match 객체 안에는 현재 컴포넌트가 어떤 경로 규칙에 의해 보이는지에 대한 정보가 들어있다.

2.  URL 쿼리 예시 : /about?details=true > 일반적으로 파라미터는 특정 아이디 혹은 이름을 사용하여 조회할 때, 그리고 쿼리는 어떤 키워드를 검색하거나 페이지에 필요한 옵션을 전달할 때 사용한다.

> 쿼리는 location 객체에 들어 있는 search 값에서 조회할 수 있다. 이 객체는 route로 사용된 컴포넌트에게 props로 전달되며, 웹 애플리케이션의 현재 주소에 대한 정보를 갖고 있다.
> location의 형태 - http://localhost:3000/about?/detail=true
> {

    "pathname" : "/about",
    "search" : "?detail=true",
    "hash" : ""
    }

> URL 쿼리를 읽을 때는 위 객체가 지닌 값 중에서 search 값을 확인해야 한다. 이 값은 문자열 형태로 되어있다. 이 값을 통해 여러가지 설정을 해줄 수 있다. search 값에서 특정 값을 읽어오기 위해서는 이 문자열을 객체형태로 변환해야 한다.
> 쿼리 문자열을 객체로 변환할 때는 qs라는 라이브러리를 사용한다. 즉, location.search 값에 있는 detail이 true인지 아닌지에 따라 추가정보를 보여주도록 만들 수 있다.
> 쿼리를 사용할 때에는 쿼리 문자열을 객체로 파싱하는 과정에서 결과값은 언제나 문자열이라는 점에 주의해라. ?value=1 or ?value=true와 같이 숫자나 논리 자료형을 사용한다고 해서 우리가 원하는 형태로 변환되는 것이 아니라 "1", "ture"와 같이 문자열 형태로 return된다.
> 따라서 숫자를 받아 와야 하면 parseInt 함수를 통해 꼭 숫자로 변환하고 지금처럼 논리 자료형 값을 사용해야 하는 경우에는 정확히 'true' 문자열과 일치하는지 비교해라.

### 서브라우트

서브라우트는 라우트 내부에 또 라우트를 정의하는 것을 의미한다. 라우트로 사용되고 있는 컴포넌트 내부에 Route 컴포넌트를 또 사용하면 된다.

### history 객체

- history 객체는 라우트로 사용된 컴포넌트에 match, location과 함께 전달되는 props중 하나로, 이 객체를 통해 컴포넌트 내에 구현하는 메서드에서 라우터 API를 호출할 수 있다.
- 특정 버튼을 눌렀을 때 뒤로 가거나 로그인 후 화면 전환을 하거나, 다른 페이지로 이탈하는 것을 방지해야 할 때 history를 활용한다.

### withRouter method of react-router-dom

- HoC(Hither-order Component)로서 라우트로 사용된 컴포넌트가 아니어도 match, location, history 객체를 접근할 수 있게 해준다(기존에는 router로 사용된 컴포넌트의 props에서 접근).
- withRouter를 사용하면 현재 자신을 보여주고 있는 route component를 기준으로 match가 전달됨. routing path 설정할 때 참고할 것.
